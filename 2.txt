#include "aligner.h"
#include "WRException.h"

std::string GrayModelLabelStr= ClassFactory< std::string, AlignBase>::RegisterCreatorFunction(
            std::string("Gray"), GrayAlignment::Creator);
std::string FrequencyModelLabelStr= ClassFactory< std::string, AlignBase>::RegisterCreatorFunction(
            std::string("Frequency"), FrequencyAlignment::Creator);
std::string EdgeModelLabelStr= ClassFactory< std::string, AlignBase>::RegisterCreatorFunction(
            std::string("Edge"), EdgeAlignment::Creator);
std::string FastSADModelLabelStr= ClassFactory< std::string, AlignBase>::RegisterCreatorFunction(
            std::string("FastSAD"), FastSADAlignment::Creator);


Aligner::Aligner(){
    mX = 0.0f; mY = 0.0f; mScore = 0.0f;
    mMapD=new WRMat();
    mMapE=new WRMat();
    mBuf=new WRMat();
    mBuf0=new WRMat();
    isMarkSelected=false;
    mLmSelect=new LandMarkSelection();
}

Aligner::~Aligner(){
    if(mMapD){delete mMapD; mMapD=NULL;}
    if(mMapE){delete mMapD; mMapD=NULL;}
    if(mBuf){delete mMapD; mMapD=NULL;}
    if(mBuf0){delete mMapD; mMapD=NULL;}
    if(mLmSelect){delete mLmSelect;mLmSelect=NULL;}
}

void Aligner::Init(){
    int m,n;
    AlgoConfig::instance()->getImgSize(m,n);
    mMapD->Alloc(ipp::IwiSize(m,n), ipp32f, 1);
    mMapE->Alloc(ipp::IwiSize(m,n), ipp32f, 1);
    mBuf->Alloc(ipp::IwiSize(m,n), ipp32f, 1);
    mBuf0->Alloc(ipp::IwiSize(m,n), ipp32f, 1);
    mLmSelect->Init();
}

void Aligner::UnInit(){
    if(mMapD->Exists()) mMapD->Release();
    if(mMapE->Exists()) mMapD->Release();
    if(mBuf->Exists()) mMapD->Release();
    if(mBuf0->Exists()) mMapD->Release();
    mLmSelect->UnInit();
}

void Aligner::doAlign(WRMat& ref, WRMat& test)
{
    mAligner->SetTestImg(test);
    mAligner->SetRefImg(ref);
    IwiRoi roi={0, 0, test.m_size.width, test.m_size.height};
    //confirm alignment model
    if(mLmSelect->mLandMarkFlag){
        mTmpModel=globalAlign;
    }
    else{
        mTmpModel=localAlign;
    }

    //do align
    switch (mTmpModel) {
    case globalAlign:
        try{
        LOG_INFO("Do Global Alignment.");
        doGlobalAlign(ref, test);
    }catch(const WRException &er){
            LOG_INFO("Global LandMark Select Run Failed", er.what());
            exit(-1);
        }
        break;
    case localAlign:
        try{
        LOG_INFO("Do Local Alignment.");
        mAligner->doAlign(roi);
        mScore = mAligner->getOffset(mX, mY);
    }catch(const WRException &er){
            LOG_INFO("Local Alignment Run Failed", er.what());
            exit(-1);
        }
    default:
        LOG_INFO("Alignment Model Not Selected.");
        break;
    }
    //check the alignment score

}

void Aligner::doGlobalAlign(WRMat &ref, WRMat &test){

    if(!isMarkSelected){
        LOG_INFO("Global LandMark Points Select Begin.");
        isMarkSelected=true;
        mLmSelect->doMarkSelection(test);
        landMarkPoints=mLmSelect->getResult();
    }
    landMarkShift(ref, test, landMarkPoints);
    mulPointsMedian(refShift, landMarkPoints);
    refShift.clear();
}

void Aligner::mulPointsMedian(std::multimap<float, IppiPoint> refShift, std::vector<IppiPoint> landMarkPoints){

    std::vector<float> indexX, indexY, score;
    indexX.reserve(refShift.size());
    indexY.reserve(refShift.size());
    score.reserve(refShift.size());
    for(const auto & pair: refShift){
        indexX.push_back(pair.second.y);
        indexY.push_back(pair.second.x);
        score.push_back(pair.first);
    }

    std::sort(indexX.begin(), indexX.end());
    std::sort(indexY.begin(), indexY.end());
    std::sort(score.begin(), score.end());


    if(refShift.empty()){
        LOG_INFO("LandMark No Pattern Signal.");
        return;
    }
    else if(refShift.size()==1){
        mX=indexX[0];
        mY=indexY[0];
        mScore=score[0];
    }
    else{
        int mid = indexX.size() / 2;
        if (indexX.size() % 2 == 0) {
            mX = (indexX[mid - 1] + indexX[mid]) / 2.0f;
            mY = (indexY[mid - 1] + indexY[mid]) / 2.0f;
            mScore = (score[mid - 1] + score[mid]) / 2.0f;
        } else {
            mX = indexX[mid];
            mY = indexY[mid];
            mScore = score[mid];
        }
    }
    LOG_INFO("LandMark final shift : mX ", mX, " mY ", mY, " mScore :", mScore);
}

void Aligner::landMarkShift(WRMat &ref, WRMat &test, std::vector<IppiPoint> landMarkPoints){
    IppStatus st = ippStsNoErr;
    ipp::IwiRoi roi;
    IwiBorderSize initBorder=mAligner->mAlignMap.m_inMemSize;
    IppiPoint center, point, finalPt;
    int ws = mLmSelect->mWinSize;
    float score;

    for(size_t i=0; i<landMarkPoints.size(); i++){
        roi = {landMarkPoints[i].y-ws, landMarkPoints[i].x-ws, 2*ws+1, 2*ws+1};
        center={ws,ws};
        mAligner->mAlignMap.RoiSet(roi);
        mAligner->doAlign(roi);
        st |= findCandidate(mAligner->mAlignMap, mLmSelect->thresh, position);

        if(!position.empty()){
            point=finalShift(position, center, finalPt);
            score=*(Ipp32f*)mAligner->mAlignMap.ptr(finalPt.x,finalPt.y,0);
            LOG_INFO("The ",i ," LandMark Final Shift : mX ", point.y, " mY ", point.x, " mScore :", score);
            refShift.insert(std::pair<float, IppiPoint>(score,point));
            position.clear();
        }
        else
            LOG_INFO("The ","i ","LandMark No Peaks.");
        st |= iwiImage_BorderSet(dynamic_cast<ipp::IwiImage*>(&mAligner->mAlignMap),initBorder);
    }
    WR_ERROR_CHECK(st);
}

IppStatus Aligner::findCandidate(WRMat& map, Ipp32f thresh, std::vector<IppiPoint>& position){
    IppStatus st = ippStsNoErr;
    int width = map.m_size.width, height = map.m_size.height;
    IppiSize roi = {width, height};
    Ipp32f minVal, maxVal;
    IppiPoint minIndex, maxIndex, point;
    st |= ippiMinMaxIndx_32f_C1R((Ipp32f*)map.m_ptr, map.m_step, roi, &minVal, &maxVal, &minIndex, &maxIndex);
    WRMat kernel;
    //default min peak distance
    IppiSize kernel_size = {50, 50};
    kernel.Alloc(kernel_size, ipp8u, 1);
    double val = 1.0;
    iwiSet(&val, 1, &kernel, NULL, NULL, NULL);

    IwiBorderSize initBorder=mMapD->m_inMemSize;
    mMapD->RoiSet(ipp::IwiRoi(0, 0, width, height));
    mMapE->RoiSet(ipp::IwiRoi(0, 0, width, height));
    mBuf->RoiSet(ipp::IwiRoi(0, 0, width, height));
    mBuf0->RoiSet(ipp::IwiRoi(0, 0, width, height));

    //normalize
    st |= ippiSubC_32f_C1R((Ipp32f*)map.m_ptr, map.m_step, minVal, (Ipp32f*)mBuf0->m_ptr, mBuf0->m_step, roi);
    st |= ippiDivC_32f_C1IR(maxVal-minVal, (Ipp32f*)mBuf0->m_ptr, mBuf0->m_step, roi);

    st |= iwiFilterMorphology(dynamic_cast<ipp::IwiImage&>(*mBuf0), dynamic_cast<ipp::IwiImage&>(*mMapD),
                              ::iwiMorphDilate, kernel);
    st |= iwiFilterMorphology(dynamic_cast<ipp::IwiImage&>(*mBuf0), dynamic_cast<ipp::IwiImage&>(*mMapE),
                              ::iwiMorphErode, kernel);
    //map-mapD
    st |= ippiSub_32f_C1R((Ipp32f*)mMapD->m_ptr, mMapD->m_step, (Ipp32f*)mBuf0->m_ptr, mBuf0->m_step,
                          (Ipp32f*)mBuf->m_ptr, mBuf->m_step, roi);
    st |= ippiThreshold_GTVal_32f_C1IR((Ipp32f*)mBuf->m_ptr, mBuf->m_step, roi, -1e-6, 1);
    st |= ippiThreshold_LTVal_32f_C1IR((Ipp32f*)mBuf->m_ptr, mBuf->m_step, roi, 1, 0);

    //mapD-mapE
    st |= ippiSub_32f_C1IR((Ipp32f*)mMapE->m_ptr, mMapE->m_step, (Ipp32f*)mMapD->m_ptr, mMapD->m_step, roi);
    st |= ippiThreshold_GTVal_32f_C1IR((Ipp32f*)mMapD->m_ptr, mMapD->m_step, roi, 0.1, 1);
    st |= ippiThreshold_LTVal_32f_C1IR((Ipp32f*)mMapD->m_ptr, mMapD->m_step, roi, 1, 0);

    // mapD && mapE
    st |= ippiMul_32f_C1IR((Ipp32f*)mMapD->m_ptr, mMapD->m_step, (Ipp32f*)mBuf->m_ptr, mBuf->m_step, roi);
    for(int i=0; i<height; i++){
        Ipp32f* ptr = (Ipp32f*)mBuf->ptr(i);
        Ipp32f* ptrM = (Ipp32f*)map.ptr(i);
        for(int j=0; j<width; j++){
            if(ptr[j]!=0 && ptrM[j]>thresh){
                point.x=i, point.y=j;
                position.push_back(point);
            }
        }
    }

    st |= iwiImage_BorderSet(dynamic_cast<ipp::IwiImage*>(mMapD), initBorder);
    st |= iwiImage_BorderSet(dynamic_cast<ipp::IwiImage*>(mMapE), initBorder);
    st |= iwiImage_BorderSet(dynamic_cast<ipp::IwiImage*>(mBuf), initBorder);
    st |= iwiImage_BorderSet(dynamic_cast<ipp::IwiImage*>(mBuf0), initBorder);
    WR_ERROR_CHECK(st);
    return st;

}

IppiPoint Aligner::finalShift(std::vector<IppiPoint> pos, IppiPoint center, IppiPoint& finalPt){
    //filter final peak
    double minVal = 1e+6;
    IppiPoint result;
    for (int temp = 0; temp < pos.size(); temp++)
    {
        IppiPoint pt = pos[temp];
        double dis = getLength(pt, center);

        if (dis < minVal)
        {
            finalPt = pt;
            minVal = dis;
        }
    }
    result.x=center.x-finalPt.x;
    result.y=center.y-finalPt.y;
    return result;
}

double Aligner::getLength(IppiPoint a, IppiPoint b)
{
    double sum = std::sqrt(std::pow((b.x - a.x), 2) + std::pow((a.y - b.y), 2));
    return sum;
}

void Aligner::configure()
{
    std::string align_path = "/Inspection/Detection/D2D/Alignment";
    pugi::xml_node align_node=AlgoConfig::instance()->SelectNodes(align_path);

    pugi::xml_node template_node=align_node.child("Template");
    mTemplate=template_node.attribute("method").value();

    //create align instance
    if(!strcmp(mTemplate.c_str(), "Edge")){
        mAligner = ClassFactory<std::string, AlignBase>::CreateInstance("Edge");
        LOG("Create EdgeAlignment AlignBase Instance.");
    }
    if(!strcmp(mTemplate.c_str(), "Gray")){
        mAligner = ClassFactory<std::string, AlignBase>::CreateInstance("Gray");
        LOG("Create GrayAlignment AlignBase Instance.");
    }
    if(!strcmp(mTemplate.c_str(), "Frequency")){
        mAligner = ClassFactory<std::string, AlignBase>::CreateInstance("Frequency");
        LOG("Create FrenquencyAlignment AlignBase Instance.");
    }
    if(!strcmp(mTemplate.c_str(), "FastSAD")){
        mAligner = ClassFactory<std::string, AlignBase>::CreateInstance("FastSAD");
        LOG("Create FastSADAlignment AlignBase Instance.");
    }
    if(!mAligner){
        LOG("Aligner CreateInstance Failed !");
    }else{
        mAligner->Configure();
    }
    mLmSelect->Configure();
}

